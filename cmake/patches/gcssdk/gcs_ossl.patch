--- gcssdk-build-orig/google/cloud/storage/hashing_options.cc	2021-02-01 19:02:25.000000000 -0800
+++ gcssdk-build/google/cloud/storage/hashing_options.cc	1969-12-31 16:00:00.000000000 -0800
@@ -1,46 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "google/cloud/storage/hashing_options.h"
-#include "google/cloud/storage/internal/openssl_util.h"
-#include "google/cloud/internal/big_endian.h"
-#include <crc32c/crc32c.h>
-#include <openssl/md5.h>
-#include <cstring>
-
-namespace google {
-namespace cloud {
-namespace storage {
-inline namespace STORAGE_CLIENT_NS {
-std::string ComputeMD5Hash(std::string const& payload) {
-  MD5_CTX md5;
-  MD5_Init(&md5);
-  MD5_Update(&md5, payload.c_str(), payload.size());
-
-  std::string hash(MD5_DIGEST_LENGTH, ' ');
-  MD5_Final(reinterpret_cast<unsigned char*>(&hash[0]), &md5);
-  return internal::Base64Encode(hash);
-}
-
-std::string ComputeCrc32cChecksum(std::string const& payload) {
-  auto checksum = crc32c::Extend(
-      0, reinterpret_cast<std::uint8_t const*>(payload.data()), payload.size());
-  std::string const hash = google::cloud::internal::EncodeBigEndian(checksum);
-  return internal::Base64Encode(hash);
-}
-
-}  // namespace STORAGE_CLIENT_NS
-}  // namespace storage
-}  // namespace cloud
-}  // namespace google
--- gcssdk-build-orig/google/cloud/storage/internal/hash_validator_impl.h	2021-02-01 19:02:25.000000000 -0800
+++ gcssdk-build/google/cloud/storage/internal/hash_validator_impl.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,76 +0,0 @@
-// Copyright 2019 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef GOOGLE_CLOUD_CPP_GOOGLE_CLOUD_STORAGE_INTERNAL_HASH_VALIDATOR_IMPL_H
-#define GOOGLE_CLOUD_CPP_GOOGLE_CLOUD_STORAGE_INTERNAL_HASH_VALIDATOR_IMPL_H
-
-#include "google/cloud/storage/internal/hash_validator.h"
-#include "google/cloud/storage/version.h"
-#include <openssl/md5.h>
-
-namespace google {
-namespace cloud {
-namespace storage {
-inline namespace STORAGE_CLIENT_NS {
-class ObjectMetadata;
-namespace internal {
-/**
- * A validator based on MD5 hashes.
- */
-class MD5HashValidator : public HashValidator {
- public:
-  MD5HashValidator();
-
-  MD5HashValidator(MD5HashValidator const&) = delete;
-  MD5HashValidator& operator=(MD5HashValidator const&) = delete;
-
-  std::string Name() const override { return "md5"; }
-  void Update(char const* buf, std::size_t n) override;
-  void ProcessMetadata(ObjectMetadata const& meta) override;
-  void ProcessHeader(std::string const& key, std::string const& value) override;
-  Result Finish() && override;
-
- private:
-  MD5_CTX context_;
-  std::string received_hash_;
-};
-
-/**
- * A validator based on CRC32C checksums.
- */
-class Crc32cHashValidator : public HashValidator {
- public:
-  Crc32cHashValidator() = default;
-
-  Crc32cHashValidator(Crc32cHashValidator const&) = delete;
-  Crc32cHashValidator& operator=(Crc32cHashValidator const&) = delete;
-
-  std::string Name() const override { return "crc32c"; }
-  void Update(char const* buf, std::size_t n) override;
-  void ProcessMetadata(ObjectMetadata const& meta) override;
-  void ProcessHeader(std::string const& key, std::string const& value) override;
-  Result Finish() && override;
-
- private:
-  std::uint32_t current_{0};
-  std::string received_hash_;
-};
-
-}  // namespace internal
-}  // namespace STORAGE_CLIENT_NS
-}  // namespace storage
-}  // namespace cloud
-}  // namespace google
-
-#endif  // GOOGLE_CLOUD_CPP_GOOGLE_CLOUD_STORAGE_INTERNAL_HASH_VALIDATOR_IMPL_H
--- gcssdk-build-orig/google/cloud/storage/internal/hash_validator_impl.cc	2021-02-01 19:02:25.000000000 -0800
+++ gcssdk-build/google/cloud/storage/internal/hash_validator_impl.cc	1969-12-31 16:00:00.000000000 -0800
@@ -1,114 +0,0 @@
-// Copyright 2019 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "google/cloud/storage/internal/hash_validator_impl.h"
-#include "google/cloud/storage/internal/openssl_util.h"
-#include "google/cloud/storage/object_metadata.h"
-#include "google/cloud/internal/big_endian.h"
-#include <crc32c/crc32c.h>
-
-namespace google {
-namespace cloud {
-namespace storage {
-inline namespace STORAGE_CLIENT_NS {
-namespace internal {
-MD5HashValidator::MD5HashValidator() : context_{} { MD5_Init(&context_); }
-
-void MD5HashValidator::Update(char const* buf, std::size_t n) {
-  MD5_Update(&context_, buf, n);
-}
-
-void MD5HashValidator::ProcessMetadata(ObjectMetadata const& meta) {
-  if (meta.md5_hash().empty()) {
-    // When using the XML API the metadata is empty, but the headers are not. In
-    // that case we do not want to replace the received hash with an empty
-    // value.
-    return;
-  }
-  received_hash_ = meta.md5_hash();
-}
-
-void MD5HashValidator::ProcessHeader(std::string const& key,
-                                     std::string const& value) {
-  if (key != "x-goog-hash") {
-    return;
-  }
-  char const prefix[] = "md5=";
-  auto constexpr kPrefixLen = sizeof(prefix) - 1;
-  auto pos = value.find(prefix);
-  if (pos == std::string::npos) {
-    return;
-  }
-  auto end = value.find(',', pos);
-  if (end == std::string::npos) {
-    received_hash_ = value.substr(pos + kPrefixLen);
-    return;
-  }
-  received_hash_ = value.substr(pos + kPrefixLen, end - pos - kPrefixLen);
-}
-
-HashValidator::Result MD5HashValidator::Finish() && {
-  std::string hash(MD5_DIGEST_LENGTH, ' ');
-  MD5_Final(reinterpret_cast<unsigned char*>(&hash[0]), &context_);
-  auto computed = Base64Encode(hash);
-  bool is_mismatch = !received_hash_.empty() && (received_hash_ != computed);
-  return Result{std::move(received_hash_), std::move(computed), is_mismatch};
-}
-
-void Crc32cHashValidator::Update(char const* buf, std::size_t n) {
-  current_ =
-      crc32c::Extend(current_, reinterpret_cast<std::uint8_t const*>(buf), n);
-}
-
-void Crc32cHashValidator::ProcessMetadata(ObjectMetadata const& meta) {
-  if (meta.crc32c().empty()) {
-    // When using the XML API the metadata is empty, but the headers are not. In
-    // that case we do not want to replace the received hash with an empty
-    // value.
-    return;
-  }
-  received_hash_ = meta.crc32c();
-}
-
-void Crc32cHashValidator::ProcessHeader(std::string const& key,
-                                        std::string const& value) {
-  if (key != "x-goog-hash") {
-    return;
-  }
-  char const prefix[] = "crc32c=";
-  auto constexpr kPrefixLen = sizeof(prefix) - 1;
-  auto pos = value.find(prefix);
-  if (pos == std::string::npos) {
-    return;
-  }
-  auto end = value.find(',', pos);
-  if (end == std::string::npos) {
-    received_hash_ = value.substr(pos + kPrefixLen);
-    return;
-  }
-  received_hash_ = value.substr(pos + kPrefixLen, end - pos - kPrefixLen);
-}
-
-HashValidator::Result Crc32cHashValidator::Finish() && {
-  std::string const hash = google::cloud::internal::EncodeBigEndian(current_);
-  auto computed = Base64Encode(hash);
-  bool is_mismatch = !received_hash_.empty() && (received_hash_ != computed);
-  return Result{std::move(received_hash_), std::move(computed), is_mismatch};
-}
-
-}  // namespace internal
-}  // namespace STORAGE_CLIENT_NS
-}  // namespace storage
-}  // namespace cloud
-}  // namespace google
--- gcssdk-build-orig/google/cloud/storage/internal/sha256_hash.cc	2021-02-01 19:02:25.000000000 -0800
+++ gcssdk-build/google/cloud/storage/internal/sha256_hash.cc	1969-12-31 16:00:00.000000000 -0800
@@ -1,82 +0,0 @@
-// Copyright 2019 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "google/cloud/storage/internal/sha256_hash.h"
-#include <openssl/evp.h>
-#include <openssl/sha.h>
-#include <array>
-
-namespace google {
-namespace cloud {
-namespace storage {
-inline namespace STORAGE_CLIENT_NS {
-namespace internal {
-
-namespace {
-template <typename Byte,
-          typename std::enable_if<sizeof(Byte) == 1, int>::type = 0>
-std::vector<std::uint8_t> Sha256Hash(Byte const* data, std::size_t count) {
-  SHA256_CTX sha256;
-  SHA256_Init(&sha256);
-  SHA256_Update(&sha256, data, count);
-
-  std::array<unsigned char, SHA256_DIGEST_LENGTH> hash{};
-  SHA256_Final(hash.data(), &sha256);
-  // Note that this constructor (from a range) converts the `unsigned char` to
-  // `std::uint8_t` if needed, this should work because (a) the values returned
-  // by `SHA256_Final()` are 8-bit values, and (b) because if `std::uint8_t`
-  // exists it must be large enough to fit an `unsigned char`.
-  return {hash.begin(), hash.end()};
-}
-}  // namespace
-
-std::vector<std::uint8_t> Sha256Hash(std::string const& str) {
-  return Sha256Hash(str.data(), str.size());
-}
-
-std::vector<std::uint8_t> Sha256Hash(std::vector<std::uint8_t> const& bytes) {
-  return Sha256Hash(bytes.data(), bytes.size());
-}
-
-std::string HexEncode(std::vector<std::uint8_t> const& bytes) {
-  std::string result;
-  std::array<char, sizeof("ff")> buf{};
-  for (auto c : bytes) {
-    std::snprintf(buf.data(), buf.size(), "%02x", c);
-    result += buf.data();
-  }
-  return result;
-}
-
-std::vector<std::uint8_t> HexDecode(std::string const& str) {
-  if (str.size() % 2 != 0) return {};
-
-  std::vector<std::uint8_t> result;
-  result.reserve(str.size() / 2);
-  for (char const* p = str.data(); p != str.data() + str.size(); p += 2) {
-    std::string s{p, p + 2};
-    std::size_t idx = 0;
-    auto constexpr kBaseForHex = 16;
-    auto v = std::stol(s, &idx, kBaseForHex);
-    if (idx != 2) return {};
-    result.push_back(static_cast<std::uint8_t>(v));
-  }
-  return result;
-}
-
-}  // namespace internal
-}  // namespace STORAGE_CLIENT_NS
-}  // namespace storage
-}  // namespace cloud
-}  // namespace google
